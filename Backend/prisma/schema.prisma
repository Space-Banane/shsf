generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  Admin
  User
}

model User {
  id          Int      @id @default(autoincrement())
  displayName String   @db.VarChar(128)
  email       String   @unique
  role        UserRole @default(User)

  password String? @db.VarChar(256)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  sessions     Session[]
  functions    Function[]
  namespaces   Namespace[]
  accessTokens AccessToken[]
  storages     FunctionStorage[]
  guestUsers   GuestUser[]
}

model Session {
  id   Int    @id @default(autoincrement())
  hash String @db.Text

  userId Int
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Function {
  id          Int    @id @default(autoincrement())
  name        String @db.VarChar(128)
  description String @db.VarChar(256)
  image       String @db.VarChar(256)

  executionId String @unique @db.VarChar(256) // Unique identifier for the function execution
  executionAlias String? @db.VarChar(128) @unique // Human-readable alias for the function execution

  userId Int
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  max_ram       Int     @default(512)
  timeout       Int     @default(15)
  allow_http    Boolean @default(true)
  env           String? @db.Text // Environment variables in JSON format (comma separated key=value pairs)
  secure_header String? @db.VarChar(256)

  retry_on_failure Boolean @default(false)
  max_retries      Int     @default(3)

  tags         String? @db.Text // comma separated tags
  startup_file String? @db.VarChar(256) // Replaced startup_command with startup_file
  cors_origins String? @db.Text // Comma separated list of allowed CORS origins

  // Extra Cool shit
  docker_mount Boolean @default(false) // Whether to mount a Docker socket
  ffmpeg_install Boolean @default(false) // Whether to install ffmpeg in the function environment

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  lastRun   DateTime? // Last time the function was executed

  namespaceId Int
  namespace   Namespace @relation(fields: [namespaceId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  files      FunctionFile[]
  triggers   FunctionTrigger[]
  TriggerLog TriggerLog[]
}

model FunctionFile {
  id      Int    @id @default(autoincrement())
  name    String @db.VarChar(256)
  content String @db.Text

  functionId Int
  function   Function @relation(fields: [functionId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Namespace {
  id   Int    @id @default(autoincrement())
  name String @db.VarChar(128)

  userId Int
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  functions Function[]
}

model FunctionTrigger {
  id          Int    @id @default(autoincrement())
  name        String @db.VarChar(128)
  description String @db.VarChar(256)
  cron        String @db.VarChar(128) // Cron expression for scheduling
  data        Json?

  enabled Boolean @default(true)

  functionId Int
  function   Function @relation(fields: [functionId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  lastRun   DateTime? // Last time the trigger was executed
  nextRun   DateTime? // Next time the trigger is scheduled to run
}

model TriggerLog {
  id         Int      @id @default(autoincrement())
  functionId Int
  function   Function @relation(fields: [functionId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  result     String?  @db.Text // Result of the function execution
  logs       String   @db.Text // Logs from the function execution

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model AccessToken {
  id        Int       @id @default(autoincrement())
  token     String    @unique @db.VarChar(256)
  name      String    @db.VarChar(128)
  purpose   String?   @db.VarChar(512)
  
  expiresAt DateTime?
  expired   Boolean   @default(false)
  hidden    Boolean   @default(false)

  userId Int
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model FunctionStorage {
  id         Int    @id @default(autoincrement())
  name       String @db.VarChar(128)
  purpose    String @db.VarChar(256)

  user Int
  userRel User @relation(fields: [user], references: [id], onDelete: Cascade, onUpdate: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  items FunctionStorageItem[]
}

model FunctionStorageItem {
  id               Int    @id @default(autoincrement())
  key              String @db.VarChar(256)
  value            String @db.Text

  storageId Int
  storage   FunctionStorage @relation(fields: [storageId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  expiresAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model GuestUser {
  id         Int      @id @default(autoincrement())
  displayName String   @db.VarChar(128)
  email       String   @unique

  permittedFunctions Json // List of numeric Function IDs (database IDs) the guest user is permitted to access  
  password_hash String @db.VarChar(256)

  guestOwnerId Int
  guestOwner   User @relation(fields: [guestOwnerId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  sessions GuestSession[]
}

model GuestSession {
  id   Int    @id @default(autoincrement())
  hash String @db.Text

  guestUserId Int
  guestUser   GuestUser @relation(fields: [guestUserId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  expiresAt DateTime
}